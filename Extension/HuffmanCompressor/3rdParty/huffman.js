/**
 * JavaScript implementation of the Huffman Coding algorithm
 * used to compress data.
 *
 * @author http://www.kuederle.com
 */
 
/**
 * The main class used to encode or decode data using Huffman Coding.
 * Data to be compressed can either be an array of any objects or
 * a string. Compressed data will be either an array of 32-bit integers
 * or a string (see compressData() for more information).
 *
 * For the array version, you must make sure the toString() function
 * of the objects in the array returns a unique string for the object.
 *
 * At the same time, this class represents the Huffman tree itself.
 *
 * @param dictionary This is either an array or a string used to construct the tree.
 *			At even indices, the dictionary contains the output value (e.g. a letter).
 *			At odd indices, the dictionary contains the output values' compressed bit length.
 *			This dictionary is generated by this class and can be used to initialize an
 *			already existing tree.
 */
function Huffman(dictionary) {

	/** The root node of the tree. */
	var root;
	
	/** An associative array of leaves in the tree (value => node). */
	var leaves = new Object();
	
	/**
	 * Build the Huffman tree with the given dictionary.
	 *
	 * @param dictionary The dictionary. See class description.
	 * @return The size of the dictionary.
	 */
	this.setDictionary = function(dictionary) {
		if(!dictionary)
			throw "No dictionary provided.";
		root = new Node();
		if(typeof dictionary == "string")
			dictionary = dictionary.split("");
		dictionary.nextIndex = 0;
		root.setDictionary(dictionary,0);
		var size = dictionary.nextIndex;
		delete dictionary.nextIndex;
		return size;
	}
	
	/**
	 * Return a string or an array of objects which represents the tree.
	 * For more information, see class description.
	 *
	 * @param asArray (Optional) Whether or not the dictionary should
	 *					be returned as an array (default = false). If this
	 *					value is false, a string is returned.
	 * @return the dictionary.
	 */
	this.getDictionary = function(asArray) {
		var dictionary = new Array();
		if(!root)
			throw "Impossible to extract dictionary from non-existing tree.";
		root.getDictionary(dictionary,0);
		if(!asArray)
			return dictionary.join("");
		else
			return dictionary;
	}
	
	/**
	 * Builds the tree according to the Huffman algorithm. There is
	 * lots of information about this out there (e.g. Wikipedia).
	 *
	 * @param data This is the data from which the tree is built. This
	 *				can be either a string or an array of objects/values.
	 *				If objects are contained, their toString() function
	 *				must return a unique string used to distinguish the objects.
	 */
	this.buildTree = function(data) {
		// The root nodes while we have more than one of them.
		// This is an associative array with valueToString(value)
		// as the key and the node as the value.
		var roots = new Object();

		if(typeof data == "string")
			data = data.split("");
		
		// Determine frequencies.
		for(var index=0;index < data.length;index++) {
			var key;
			key = data[index];

			// Add value if new.
			if(!roots[key]) {
				roots[key] = new Node(key);
				leaves[key] = roots[key];
			}
				
			roots[key].frequency++;
		}
		
		// Convert to a regular array.
		var arr = new Array();
		for(var key in roots)
			arr.push(roots[key]);
		roots = arr;

		// We want at least two different items.
		if(arr.length === 1) {
			key = key.length === 1 ? String.fromCharCode(255 - key.charCodeAt(0)) : key + "+";
			var artificial = new Node(key);
			roots[key] = artificial;
			leaves[key] = artificial;
			arr.push(artificial);
		}		

		// Create a tree.
		while(roots.length > 1) {
			// Find two nodes with the lowest frequency.
			var leastOften,secondLeastOften;
			if(roots[0].frequency < roots[1].frequency) {
				leastOften = 0;
				secondLeastOften = 1;
			} else {
				leastOften = 1;
				secondLeastOften = 0;
			}
			for(var index=2;index < roots.length;index++)
				if(roots[index].frequency < roots[leastOften].frequency) {
					secondLeastOften = leastOften;
					leastOften = index;
				} else if(roots[index].frequency < roots[secondLeastOften].frequency)
					secondLeastOften = index;
					
			// Merge those two nodes.
			var node = new Node();
			var leastZero = true;
			if(roots[leastOften].height > roots[secondLeastOften].height)
				leastZero = false;
			else if(roots[leastOften].height == roots[secondLeastOften].height
				&& roots[leastOften].value > roots[secondLeastOften].value)
				leastZero = false;
			if(leastZero) {
				node.zeroChild = roots[leastOften];
				node.oneChild = roots[secondLeastOften];
			} else {
				node.zeroChild = roots[secondLeastOften];
				node.oneChild = roots[leastOften];
			}
			node.frequency = node.zeroChild.frequency + node.oneChild.frequency;
			node.height = 1 + Math.max(node.zeroChild.height,node.oneChild.height);
			node.zeroChild.parent = node;
			node.oneChild.parent = node;
			roots[leastOften] = node;
			roots.splice(secondLeastOften,1);
		}
		
		root = roots[0];
	}
	
	/**
	 * Converts a 32-bit integer to a 4-letter string.
	 *
	 * @param value The 32-bit integer.
	 * @return The 4-letter string.
	 */
	function intToString(value) {
		return String.fromCharCode((value >> 24) & 0xFF,
							(value >> 16) & 0xFF,
							(value >> 8) & 0xFF,
							value & 0xFF);
	}
	
	/**
	 * Compresses the given data using the currently present
	 * Huffman tree.
	 *
	 * @param data An array of 32-bit values or a string which is
	 *				compressed.
	 * @param asArray (Optional) Whether or not the compressed data
	 *				is returned as an array of 32-bit values. If this
	 *				value is false (=default), a string is returned.
	 * @return The compressed form of the data.
	 */
	this.compressData = function(data,asArray) {
		var dword = 0;		// Current 32-bit value.
		var bitsLeft = 32;	// Number of bits left in dword.

		var compressed;
		if(!asArray)
			compressed = intToString(data.length);
		else {
			compressed = new Array();
			compressed.push(data.length);
		}
		
		if(typeof data == "string")
			data = data.split("");
		for(var index=0;index < data.length;index++) {
			// Match data with node.
			var key = data[index];
			var node = leaves[key];
			if(!node)
				throw "Huffman tree does not match input data.";
			
			// If this leaf has no bit value yet, do it
			// now by moving towards the root.
			if(node.bitLength == 0) {
				node.bits = 0;
				var current = node;
				while(current.parent) {
					if(current.parent.oneChild == current)
						node.bits |= (1 << node.bitLength);
					node.bitLength++;
					current = current.parent;
				}
			}
			
			// Add bits of node to the data stream.
			if(bitsLeft >= node.bitLength) {
				// It fits into the dword.
				dword = (dword << node.bitLength) | node.bits;
				bitsLeft -= node.bitLength;
			} else {
				// It it doesn't fit, split.
				dword = (dword << bitsLeft) | (node.bits >>> (node.bitLength - bitsLeft));
				var value = dword & 0xffffffff;
				if(!asArray)
					compressed += intToString(value);
				else
					compressed.push(value);
				dword = node.bits;
				bitsLeft = 32 - (node.bitLength - bitsLeft);
			}

		}
		var value = (dword << bitsLeft) & 0xffffffff;
		if(!asArray)
			compressed += intToString(value);
		else
			compressed.push(value);
		
		return compressed;
	}
	
	/**
	 * Compresses data. The resulting compressed data will
	 * contain all that's needed to decompress it, i.e. it
	 * will include the dictionary as well. The data type is
	 * maintained. That is, if a string is input, a string
	 * is output. If an array of objects/values is input,
	 * an array of objects/values is output.
	 *
	 * @param data A string or an array of objects/values to be compressed.
	 * @return The compressed data (string or array).
	 * @see compressData()
	 */
	this.compress = function(data) {
		this.buildTree(data);
		var asArray = !(typeof data == "string");
		return this.getDictionary(asArray).concat(this.compressData(data,asArray));
	}
	
	/**
	 * Converts a 4-letter string into a 32-bit integer.
	 *
	 * @param str The 4-letter string.
	 * @return The 32-bit integer.
	 */
	function stringToInt(str) {
		return (str.charCodeAt(0) << 24)
				| (str.charCodeAt(1) << 16)
				| (str.charCodeAt(2) << 8)
				| str.charCodeAt(3);
	}
	
	/**
	 * Decompresses data which was compressed with the
	 * compress function and returns the original data.
	 *
	 * @param compressed The compressed data stream. This is either an
	 *			array of 32-bit values or a string.
	 * @param asArray (optional) Whether or not the resulting data should be
	 *			an array of objects/values. If false, a string is returned.
	 *			If the original data was not a string, decompressing to a
	 *			string may lead to unexpected behaviour. Default is false.
	 * @param startIndex (optional) If the decompression data doesn't start
	 *			at index 0 (the default), for example if the dictionary
	 *			precedes the decompression data, use this index to indicate
	 *			the start.
	 * @return The decompressed values, an array of 32-bit values or
	 *			a string.
	 */
	this.decompressData = function(compressed,asArray,startIndex) {
		// Some initialization.
		var index = 0;
		var bitIndex = 32;
		var data = new Array();
		var compressedIndex;
		if(!startIndex)
			compressedIndex = 0;
		else
			compressedIndex = startIndex;
		var count;
		if(typeof compressed == "string") {
			count = stringToInt(compressed.substr(compressedIndex,4));
			compressedIndex += 4;
		} else {
			count = compressed[compressedIndex];
			compressedIndex++;
		}
		
		// Process incoming bits.
		while(index < count) {
			// Traverse the tree until we hit a leaf.
			var node = root;
			while(!node.value) {
				// Get the next bit.
				var value;
				if(typeof compressed == "string")
					value = stringToInt(compressed.substr(compressedIndex,4));
				else
					value = compressed[compressedIndex];
				var bit = (value >> (bitIndex - 1)) & 1;
				bitIndex--;
				if(bitIndex==0) {
					if(typeof compressed == "string")
						compressedIndex += 4;
					else
						compressedIndex++;
					bitIndex = 32;
				}

				if(bit)
					node = node.oneChild;
				else
					node = node.zeroChild;
			}
			
			// We have a value.
			data.push(node.value);
			index++;
		}
		
		if(!asArray)
			return data.join("");
		else
			return data;
	}
	
	/**
	 * Decompresses a self-contained compressed
	 * bit stream. That is, the dictionary is already
	 * contained in the bit stream. If the bit stream
	 * itself is a string, a string is returned. If it
	 * is an array, an array is returned.
	 *
	 * @param bitStream The compressed data including dictionary.
	 * @return The decompressed (original) data.
	 * @see compress()
	 */
	this.decompress = function(bitStream) {
		var index = this.setDictionary(bitStream);
		var asArray = !(typeof bitStream == "string");
		return this.decompressData(bitStream,asArray,index);
	}
	
	/**
	 * Returns a string representation of this tree.
	 *
	 * @return The tree as a string.
	 */
	this.toString = function() {
		if(!root)
			return "no tree";
		else
			return root.toString();
	}

	// Constructor.
	if(dictionary)
		this.setDictionary(dictionary);
		
}

/**
 * A node in the Huffman tree.
 *
 * @param value The 32-bit value of the node.
 */
function Node(value) {

	/**
	 * If not null, this represents the uncompressed 32-bit value
	 * at this node. If null, it is an intermediary node which
	 * contains at least one child.
	 */
	this.value = value?value:null;
	
	/**
	 * The frequency of the value in the dataset or the accumulated
	 * frequency of all children if this is not a leaf node.
	 */
	this.frequency = 0;
	
	/** If not null, this is a reference to the child node representin a zero bit. */
	this.zeroChild = null;
	
	/** If not null, this is a reference to the child node representin a one bit. */
	this.oneChild = null;

	/** If not null, the parent node. */
	this.parent = null;
	
	/** The distance from the lowest leaf below this node. */
	this.height = 0;
	
	/**
	 * If not null, the bit value for this node if it is a leaf.
	 * Initialization is lazy during compression. The number of bits
	 * is given in bitLength.
	 */
	this.bits = null;
	
	/** The number of bits for this leave node. Only valid if not zero. */
	this.bitLength = 0;
	
	/**
	 * Adds new leaves from the dictionary below this node. See
	 * Huffman class for more information.
	 *
	 * @param dictionary The value array which contains the values.
	 * @param bitLength The bit length of this node.
	 */
	this.setDictionary = function(dictionary,bitLength) {
		// Left branch.
		if(dictionary[dictionary.nextIndex + 1] == bitLength + 1) {
			this.zeroChild = new Node(dictionary[dictionary.nextIndex]);
			this.zeroChild.parent = this;
			dictionary.nextIndex += 2;
		} else {
			this.zeroChild = new Node();
			this.zeroChild.parent = this;
			this.zeroChild.setDictionary(dictionary,bitLength + 1);
		}
		
		// Right branch.
		if(dictionary[dictionary.nextIndex + 1] == bitLength + 1) {
			this.oneChild = new Node(dictionary[dictionary.nextIndex]);
			this.oneChild.parent = this;
			dictionary.nextIndex += 2;
		} else {
			this.oneChild = new Node();
			this.oneChild.parent = this;
			this.oneChild.setDictionary(dictionary,bitLength + 1);
		}
	}
	
	/**
	 * Adds any leaves below this node to the dictionary. See
	 * Huffman class for more information.
	 *
	 * @param dictionary The 32-bit value array to add the leaves to.
	 * @param bitLength The bit length of this node.
	 */
	this.getDictionary = function(dictionary,bitLength) {
		if(this.value == null) {
			// No leaf, recurse.
			this.zeroChild.getDictionary(dictionary,bitLength + 1);
			this.oneChild.getDictionary(dictionary,bitLength + 1);
		} else {
			// Leaf, add.
			dictionary.push(this.value,bitLength);
		}
	}
	
	/**
	 * Returns a string representation of this node and its child nodes.
	 *
	 * @return The node as a string.
	 */
	this.toString = function() {
		var str = "";
		if(this.zeroChild)
			str += "[" + this.value + "," + this.frequency + "," + this.height + "]"
					+ "(" + this.zeroChild.toString() + "," + this.oneChild.toString() + ")";
		else
			str += "[" + this.value + "," + this.frequency + "," + this.height + "]";
		return str;
	}

}
